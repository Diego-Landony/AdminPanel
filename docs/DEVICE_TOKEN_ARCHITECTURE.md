# Device & Token Management Architecture

**Version:** 1.0
**Date:** November 2025
**Status:** Implementation in Progress

---

## Executive Summary

This document outlines the architecture for managing authentication tokens and devices in a multi-device, multi-authentication method environment (OAuth + Traditional). Based on industry best practices from leading retail apps (Starbucks, McDonald's) and Laravel Sanctum patterns.

---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Architecture Overview](#architecture-overview)
3. [Core Concepts](#core-concepts)
4. [Data Model](#data-model)
5. [Authentication Flows](#authentication-flows)
6. [Device Management](#device-management)
7. [Security Features](#security-features)
8. [Implementation Roadmap](#implementation-roadmap)
9. [API Endpoints](#api-endpoints)
10. [Best Practices](#best-practices)

---

## Problem Statement

### Business Requirements

- Users can authenticate via Google OAuth or email/password
- Users may have multiple devices (2 iPhones, 1 iPad, etc.)
- Each device should maintain independent sessions
- Old/unused devices should not accumulate indefinitely
- Tokens and devices must stay synchronized
- System must scale to thousands of users

### Technical Challenges

1. **Decoupled Lifecycle:** Tokens created before device records exist
2. **Orphaned Records:** Tokens without devices, devices without tokens
3. **Device Identification:** Distinguishing "iPhone 1" from "iPhone 2" of same user
4. **Cleanup Strategy:** When to revoke old sessions?
5. **Security:** Preventing unauthorized device access

---

## Architecture Overview

### Design Pattern: "Trusted Device Pattern"

Each physical device has a unique `device_identifier` (UUID) generated on the client. This UUID persists while the app is installed.

**Key Principles:**

1. **One Token per Device:** Each device gets its own Sanctum token
2. **Automatic Linking:** Token and device created together atomically
3. **Device Fingerprinting:** Combine attributes to detect cloning/fraud
4. **Trust Scoring:** Risk-based authentication for suspicious devices
5. **Automatic Cleanup:** Inactive devices auto-revoked after threshold

---

## Core Concepts

### 1. Device Identifier

**What:** UUID v4 generated by client app on first launch

**Format:** `550e8400-e29b-41d4-a716-446655440000`

**Properties:**
- Unique per app installation
- Persists in secure storage (Keychain/Keystore)
- Changes only if app reinstalled
- Sent in all auth requests

**Usage:**
```php
Token name: "ios-550e8400"  // os + first 8 chars
Device record: Full UUID stored
```

### 2. Device Fingerprint

**What:** Hash of device characteristics to detect cloning

**Components:**
```
fingerprint = SHA256(
    device_model +      // "iPhone15,2"
    os_version +        // "iOS 17.2"
    app_version +       // "1.0.5"
    screen_resolution   // "1170x2532" (optional)
)
```

**Purpose:**
- Detect if someone clones device_identifier
- Flag suspicious devices (fingerprint changed)
- Enhance fraud detection

### 3. Trust Score

**What:** 0-100 score indicating device trustworthiness

**Calculated from:**
```php
trust_score = weighted_sum([
    login_count * 10,              // More logins = more trust
    days_since_first_login * 5,    // Older device = more trust
    fingerprint_consistency * 20,  // Stable fingerprint = trust
    failed_attempts * -30          // Failed logins = distrust
])
```

**Usage:**
- Score >80: Login directly
- Score 50-80: Require 2FA
- Score <50: Block, contact support

### 4. Token Limits

**Policy:** Maximum 5 active tokens per user

**Enforcement:**
```php
Customer::enforceTokenLimit(5);
```

**Behavior:**
- When creating 6th token, oldest token (by last_used_at) is deleted
- Associated device marked as `is_active = false`
- User notified via push notification (optional)

---

## Data Model

### PersonalAccessToken (Sanctum)

```
Table: personal_access_tokens

Columns:
- id: bigint (PK)
- tokenable_type: string (Customer class)
- tokenable_id: bigint (customer_id)
- name: string (token name: "ios-ABC12345")
- token: string (hashed token value)
- abilities: json (scopes: ['customer:basic'])
- last_used_at: timestamp (auto-updated by Sanctum)
- expires_at: timestamp (1 year from creation)
- created_at: timestamp
- updated_at: timestamp
```

### CustomerDevice

```
Table: customer_devices

Columns:
- id: bigint (PK)
- customer_id: bigint (FK → customers.id)
- sanctum_token_id: bigint (FK → personal_access_tokens.id)
- device_identifier: string (UUID, unique)
- device_fingerprint: string (SHA256 hash)
- device_type: enum (ios, android, web)
- device_name: string (user-friendly: "Juan's iPhone")
- device_model: string ("iPhone15,2")
- app_version: string ("1.0.5")
- os_version: string ("iOS 17.2")
- fcm_token: string (for push notifications)
- is_active: boolean (default: true)
- trust_score: int (0-100, default: 50)
- login_count: int (default: 0)
- last_used_at: timestamp
- created_at, updated_at, deleted_at

Foreign Keys:
- customer_id → customers.id (ON DELETE CASCADE)
- sanctum_token_id → personal_access_tokens.id (ON DELETE SET NULL)

Indexes:
- device_identifier (unique)
- sanctum_token_id
- is_active
```

---

## Authentication Flows

### Flow 1: Email/Password Registration

```
Client Request:
POST /api/v1/auth/register
{
  "name": "Juan Pérez",
  "email": "juan@example.com",
  "password": "SecurePass123",
  "password_confirmation": "SecurePass123",
  "os": "ios",
  "device_identifier": "550e8400-e29b-41d4-a716-446655440000",
  "device_fingerprint": "a1b2c3d4e5f6..." (optional)
}

Backend Process:
1. Validate request
2. Create customer record
3. enforceTokenLimit(5) → Delete oldest if ≥5
4. createToken("ios-550e8400")
5. DeviceService::syncDeviceWithToken() → Create device record
6. Return token + customer data

Response:
{
  "message": "Registro exitoso",
  "data": {
    "token": "1|abc123xyz...",
    "customer": {...}
  }
}
```

### Flow 2: Email/Password Login (Existing User)

```
Client Request:
POST /api/v1/auth/login
{
  "email": "juan@example.com",
  "password": "SecurePass123",
  "os": "ios",
  "device_identifier": "550e8400-..."
}

Backend Process:
1. Validate credentials
2. enforceTokenLimit(5)
3. Check if device exists by device_identifier
   - Exists: Update sanctum_token_id + last_used_at
   - Not exists: Create new device
4. createToken("ios-550e8400")
5. Return token

Result: Same device UUID = updates existing device, no accumulation
```

### Flow 3: Google OAuth Login

```
Client Request:
POST /api/v1/auth/oauth/google
{
  "id_token": "eyJhbGc...",
  "os": "android",
  "device_identifier": "def-456..."
}

Backend Process:
1. Verify Google token
2. Find or create customer by email
3. Link google_id if not linked
4. enforceTokenLimit(5)
5. createToken("android-def456")
6. syncDeviceWithToken()
7. Return token
```

### Flow 4: Subsequent Login from Same Device

```
User opens app on iPhone 1 (already registered):

1. App reads device_identifier from secure storage
2. POST /api/v1/auth/login with same UUID
3. Backend finds existing device
4. Deletes old token, creates new token
5. Updates device: sanctum_token_id, last_used_at, login_count++
6. Device count remains the same (no accumulation)
```

---

## Device Management

### Device Lifecycle States

```
┌──────────┐
│  ACTIVE  │ ← is_active = true, recent last_used_at
└────┬─────┘
     │
     │ 180 days no activity
     ↓
┌──────────┐
│ INACTIVE │ ← is_active = false, marked by cleanup job
└────┬─────┘
     │
     │ 360 days total inactivity
     ↓
┌──────────┐
│ DELETED  │ ← soft deleted, can be restored
└──────────┘
```

### Automatic Cleanup Rules

**Daily Scheduled Job:**
```php
Schedule::command('devices:cleanup')->daily();
```

**Rules:**
1. Device not used in 180+ days → `is_active = false`
2. Device not used in 360+ days → soft delete
3. Token expired 7+ days ago → hard delete from personal_access_tokens

### Manual Device Management

**User can:**
- View all active devices
- Revoke specific device
- Mark device as trusted (increases trust_score)

**Admin can:**
- View all customer devices
- Force revoke suspicious devices
- View device analytics

---

## Security Features

### 1. Device Fingerprint Validation

**On every login:**
```php
if ($existingDevice->device_fingerprint !== $newFingerprint) {
    // Fingerprint changed - suspicious
    $device->trust_score -= 20;

    if ($device->trust_score < 50) {
        // Require 2FA or block
        return response()->json([
            'requires_verification' => true,
            'message' => 'Please verify your identity'
        ], 403);
    }
}
```

### 2. Trust-Based Authentication

**Low Trust Device:**
```php
if ($device->trust_score < 50) {
    // Send verification email/SMS
    $customer->sendVerificationCode();
    return 'verification_required';
}
```

**High Trust Device:**
```php
if ($device->trust_score > 80) {
    // Login directly, no extra steps
    return $token;
}
```

### 3. Token Abilities (Scopes)

**Different permission levels:**
```php
// Regular customer
$token = $customer->createToken($name, ['customer:basic']);

// Admin access
$token = $admin->createToken($name, ['admin:full', 'orders:manage']);
```

**Usage in middleware:**
```php
Route::middleware('auth:sanctum', 'abilities:orders:manage')
    ->group(function() {
        // Protected routes
    });
```

### 4. Rate Limiting

**Per endpoint:**
- Login: 5 attempts per minute per IP
- OAuth: 10 attempts per minute per IP
- API general: 120 requests per minute per user

---

## Implementation Roadmap

### Sprint 1: Critical Foundation (2 hours) ✅ PRIORITY

**Goals:**
- Auto-create device when token created
- Perfect token-device synchronization
- No orphaned records

**Tasks:**
1. Create `DeviceService` with `syncDeviceWithToken()` method
2. Integrate in `AuthController::register()` and `login()`
3. Integrate in `OAuthController::google()` and `googleRegister()`
4. Add `device_fingerprint` column to `customer_devices`
5. Update `DeviceController::register()` to enrich existing devices
6. Write tests for auto-sync functionality
7. Run full test suite

**Deliverables:**
- `app/Services/DeviceService.php`
- Updated controllers
- Migration for device_fingerprint
- Tests passing

### Sprint 2: Trust Scoring (1 hour)

**Goals:**
- Implement fraud detection
- Risk-based authentication

**Tasks:**
1. Add `trust_score` and `login_count` columns
2. Implement `calculateTrustScore()` method
3. Add validation logic in login flow
4. Create command to recalculate all trust scores

**Deliverables:**
- Trust score calculation
- Validation middleware
- Admin dashboard metrics

### Sprint 3: User Device Management (1 hour)

**Goals:**
- Give users control over their devices
- Admin visibility

**Tasks:**
1. Create device management endpoints
2. Build admin dashboard for device analytics
3. Add push notifications for new device logins
4. Create device activity logs

**Deliverables:**
- `/api/v1/devices` endpoints
- Admin UI components
- Push notification integration

---

## API Endpoints

### Authentication

```
POST   /api/v1/auth/register
POST   /api/v1/auth/login
POST   /api/v1/auth/logout
POST   /api/v1/auth/logout-all
POST   /api/v1/auth/oauth/google
POST   /api/v1/auth/oauth/google/register
```

**New parameters:**
- `device_identifier` (string, optional): UUID from client
- `device_fingerprint` (string, optional): SHA256 hash of device characteristics

### Device Management

```
GET    /api/v1/devices              → List my devices
POST   /api/v1/devices/register     → Register/update device with FCM token
DELETE /api/v1/devices/{id}         → Revoke specific device
POST   /api/v1/devices/{id}/trust   → Mark device as trusted
GET    /api/v1/devices/current      → Get current device info
```

### Admin Endpoints (Future)

```
GET    /admin/devices                    → All devices (paginated)
GET    /admin/customers/{id}/devices     → Customer devices
DELETE /admin/devices/{id}/force-revoke  → Admin revoke device
GET    /admin/devices/analytics          → Device statistics
```

---

## Best Practices

### For Mobile App Developers

1. **Generate UUID on first launch:**
```javascript
// React Native
import uuid from 'react-native-uuid';

async function getDeviceIdentifier() {
    let id = await SecureStore.getItemAsync('device_identifier');
    if (!id) {
        id = uuid.v4();
        await SecureStore.setItemAsync('device_identifier', id);
    }
    return id;
}
```

2. **Include device_identifier in all auth requests:**
```javascript
const response = await fetch('/api/v1/auth/login', {
    method: 'POST',
    body: JSON.stringify({
        email: email,
        password: password,
        os: Platform.OS, // 'ios' or 'android'
        device_identifier: await getDeviceIdentifier()
    })
});
```

3. **Store token securely:**
```javascript
// Use secure storage
await SecureStore.setItemAsync('auth_token', token);
```

4. **Handle 401 gracefully:**
```javascript
if (response.status === 401) {
    // Token expired or revoked
    await SecureStore.deleteItemAsync('auth_token');
    navigation.navigate('Login');
}
```

### For Backend Developers

1. **Always use DeviceService for token creation:**
```php
// ❌ Wrong
$token = $customer->createToken('app');

// ✅ Correct
$token = $customer->createToken($tokenName);
$this->deviceService->syncDeviceWithToken(
    $customer,
    $customer->currentAccessToken(),
    $request->device_identifier,
    $request->os ?? 'app'
);
```

2. **Enforce token limits consistently:**
```php
// Before creating new token
$customer->enforceTokenLimit(5);
```

3. **Use observers for cleanup:**
```php
// PersonalAccessTokenObserver handles device deactivation
// No manual cleanup needed
```

4. **Monitor device analytics:**
```php
// Track metrics
- Average devices per user
- Device types distribution
- Inactive device rate
- Trust score distribution
```

---

## Migration Guide

### From Current State to Sprint 1

**Current State:**
- ✅ Token names with device_identifier
- ✅ Observer for token deletion
- ✅ Token limit enforcement
- ❌ Devices not auto-created

**Changes Required:**

1. **Create DeviceService:**
```bash
php artisan make:service DeviceService
```

2. **Add device_fingerprint column:**
```bash
php artisan make:migration add_device_fingerprint_to_customer_devices
```

3. **Update controllers:**
- Add DeviceService dependency injection
- Call syncDeviceWithToken() after createToken()

4. **Test thoroughly:**
```bash
php artisan test --filter=Auth
php artisan test --filter=Device
```

---

## Monitoring & Metrics

### Key Metrics to Track

1. **Active Devices:**
   - Total active devices
   - Devices per user (avg, median, p95)
   - Device type distribution (iOS vs Android)

2. **Token Health:**
   - Token creation rate
   - Token revocation rate
   - Avg token lifetime
   - Tokens hitting expiration

3. **Security Metrics:**
   - Low trust score devices
   - Fingerprint mismatches
   - Failed login attempts per device
   - Geographic anomalies

4. **User Experience:**
   - Avg devices per active user
   - Session duration
   - Re-authentication rate

---

## Troubleshooting

### Common Issues

**Issue 1: Device accumulation despite limit**
```
Symptom: User has 10+ devices, limit should be 5
Cause: enforceTokenLimit() not called before createToken()
Fix: Ensure enforceTokenLimit() runs in all auth methods
```

**Issue 2: Orphaned device records**
```
Symptom: Devices with sanctum_token_id = NULL
Cause: Token deleted but device not updated
Fix: Verify PersonalAccessTokenObserver is registered
```

**Issue 3: Same device creates multiple records**
```
Symptom: Multiple devices with same device_identifier
Cause: syncDeviceWithToken() not finding existing device
Fix: Check device_identifier query logic
```

---

## Glossary

- **Device Identifier:** UUID generated by client, uniquely identifies app installation
- **Device Fingerprint:** Hash of device characteristics, used for fraud detection
- **Trust Score:** 0-100 value indicating device trustworthiness
- **Sanctum Token:** Bearer token for API authentication
- **Token Abilities:** Permissions/scopes granted to a token
- **Token Name:** Human-readable identifier for a token (e.g., "ios-ABC123")

---

## References

- [Laravel Sanctum Documentation](https://laravel.com/docs/12.x/sanctum)
- [OAuth 2.0 Best Practices](https://oauth.net/2/)
- [Device Fingerprinting Techniques](https://stytch.com/blog/what-is-device-fingerprinting/)
- Industry patterns from: Starbucks, McDonald's, Uber mobile apps

---

## Changelog

### v1.0 - November 2025
- Initial architecture design
- Sprint 1-3 roadmap defined
- Based on industry research and best practices

---

## Contact

For questions or suggestions about this architecture:
- **Email:** dlima@subwayguatemala.com
- **Documentation:** `/docs/API_DOCUMENTATION.md`
